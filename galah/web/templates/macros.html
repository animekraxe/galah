{% macro render_submission_timeline(submissions) %}
  <!-- The chart holder -->
  <div id="timelineChart" class="stats chartContainer">
    <h2>Submission Scores</h2>
    <p>Select a submission from timeline view to focus on submission details</p>
    <small>Highlight a range to zoom in. Right-click to zoom out</small>
    <small class="right">Click the legend's labels to toggle their data</small>
    <div id="timeline" class="chart"></div>
  </div>
  <script type="text/javascript" src="/static/flot_helpers.js"></script>
  <script type="text/javascript">
    // Populate series with data about student's submissions.
    var seriesData = [ [] ];
    var seriesLabels = ["Total Score"];
    {% for i in submissions | reverse %} 
      // Compute start and end times based on submission times.
      {% if loop.first %}
	start = new Date('{{ i.timestamp }} UTC+0000');
        start.addHours(-10);
        options.timeline.xaxis.min = start;
      {% elif loop.last %}
	end = new Date('{{ i.timestamp }} UTC+0000');
        end.addHours(10);
        options.timeline.xaxis.max = end;
      {% endif %}
      {% if i.test_results and i.test_results_obj %} 
	// Push on arrays for subtests if they exist
	if (seriesData.length === 1) {
	  {% for j in i.test_results_obj.tests %}
	    seriesData.push([]);
	    seriesLabels.push("{{ j.name }}");
	  {% endfor %}
	}

        // x is time and y is score.
    	seriesData[0].push([ 
            new Date('{{ i.timestamp }} UTC+0000').getTime(),
	    {{ i.test_results_obj.score / i.test_results_obj.max_score * 100 }}
    	]);

	// Add subtest scores.
	{% for j in i.test_results_obj.tests %}
	  seriesData[{{ loop.index }}].push([
	    new Date('{{ i.timestamp }} UTC+0000').getTime(),
	    {{ j.score / j.max_score * 100 }}
	  ]);
	{% endfor %}
      {% endif %} 
    {% endfor %}

    var timelineData = [];
    for (i = 0; i < seriesData.length; ++i) {
	timelineData.push({
	    data: seriesData[i],
	    label: seriesLabels[i]
	});
    }

    var timeline = $.plot($("#timeline"), timelineData, options.timeline);
    plots["timeline"] = timeline;
  </script>
{% endmacro %}

{% macro render_grade_distribution_curve(submissions) %}
  <!-- The chart holder -->
  <div id="distributionChart" class="stats chartContainer">
    <h2>Recent submission distribution</h2>
    <div id="distribution" class="chart"></div>
  </div>
  <script type="text/javascript" src="/static/flot_helpers.js"></script>
  <script type="text/javascript">
    // Create Distribution curve.
    var distributionData = [ [] ];
    var distributionLabels = ["Total Score"];
    var distribution = [];
    var rangeCount = [ [] ];
    
    // Compute running mean and variance for normal distribution.
    var n = [0];
    var mean = [0.0];
    var variance = [0.0];
    var prev_mean = [0.0];
    {% for i in submissions %}
      {% if i.test_results and i.test_results_obj %}
	// Push on arrays for subtests if they exist
	if (distributionData.length === 1) {
	  {% for j in i.test_results_obj.tests %}
	    distributionData.push([]);
	    n.push(0);
	    mean.push(0.0);
	    variance.push(0.0);
	    prev_mean.push(0.0);
	    distributionLabels.push("{{ j.name }}");
	    users.push({});
	    rangeCount.push([]);
	  {% endfor %}
	}
    	var percent =     
    	  {{ i.test_results_obj.score / i.test_results_obj.max_score * 100 }};
        rangeCount[0].push(percent);

        // Allow multiple users to share same percentage.
        if (percent in users[0]) {
            users[0][percent] += ", {{ i.user }}";
	} else {
	    users[0][percent] = "{{ i.user }}";
	}
        ++n[0];
        prev_mean[0] = mean[0];
        mean[0] = mean[0] + (percent - mean[0]) / n[0];
        variance[0] = variance[0] + (percent - mean[0]) * (percent - prev_mean[0]);

	// Add subtest scores.
	{% for j in i.test_results_obj.tests %}
          percent = {{ j.score / j.max_score * 100 }};
          index = {{ loop.index }};
          rangeCount[index].push(percent);
          if (percent in users[index]) {
              users[index][percent] += ", {{ i.user }}";
	  } else {
	      users[index][percent] = "{{ i.user }}";
	  }
          ++n[index];
          prev_mean[index] = mean[index];
          mean[index] = mean[index] + (percent - mean[index]) / n[index];
          variance[index] = variance[index] + (percent - mean[index]) *
                        (percent - prev_mean[index]);
	{% endfor %}
      {% endif %}        
    {% endfor %}    

    stdDev = new Array(variance.length);
    for (var i = 0; i < variance.length; ++i) {
	variance[i] = variance[i] / n[i];
	stdDev[i] = Math.sqrt(variance[i]);
    }

    // Explicitly sort a and b as floats or lines will draw improperly.
    for (var i = 0; i < rangeCount.length; ++i) {
	rangeCount[i].sort(function(a, b) {
	    return parseFloat(a) - parseFloat(b);
	});
    }

    for (var i = 0; i < rangeCount.length; ++i) {
	for (var j = 0; j < rangeCount[i].length; ++j) {
	    distributionData[i].push([
		rangeCount[i][j],
		NormalDensityZx(rangeCount[i][j], mean[i], stdDev[i])
	    ]);
	}
    }

    for (var i = 0; i < rangeCount.length; ++i) {
	distribution.push({
	    data: distributionData[i],
	    label: distributionLabels[i]
	});
    }

    var distributionPlot = $.plot($("#distribution"), distribution,
				  options.distribution);

    plots["distribution"] = distributionPlot;
  </script>
{% endmacro %}
