{% macro render_submission_timeline(submissions) %}
  <!-- The chart holder -->
  <div id="timelineChart" class="stats chartContainer">
    <h2>Submission Scores</h2>
    <p>Select a submission from timeline view to focus on submission details</p>
    <small>Highlight a range to zoom in. Right-click to zoom out</small>
    <small class="right">Click the legend's labels to toggle their data</small>
    <div id="timeline" class="chart"></div>
  </div>
  <script type="text/javascript" src="/static/flot_helpers.js"></script>
  <script type="text/javascript">
    // Populate series with data about student's submissions.
    var seriesData = [ [] ];
    var seriesLabels = ["Total Score"];
    // Compute start and end times based on submission times.
    {% for i in submissions | reverse %}
      {% if loop.first %}
	start = smartTimestamp('{{ i. timestamp }}');
        start.addHours(-10);
        options.timeline.xaxis.min = start;
      {% endif %}
      {% if loop.last %}
	end = smartTimestamp('{{ i. timestamp }}');
        end.addHours(10);
        options.timeline.xaxis.max = end;
      {% endif %}
      {% if i.test_results and i.test_results_obj and
	i.test_results_obj.score is not none %}
	// Push on arrays for subtests if they exist
	if (seriesData.length === 1) {
	  {% for j in i.test_results_obj.tests %}
	    seriesData.push([]);
	    seriesLabels.push("{{ j.name }}");
	  {% endfor %}
	}

        // x is time and y is score.
    	seriesData[0].push([
	    smartTimestamp('{{ i.timestamp }}').getTime(),
	    {{ i.test_results_obj.score }}
    	]);

	// Add subtest scores.
	{% for j in i.test_results_obj.tests %}
	  seriesData[{{ loop.index }}].push([
	    smartTimestamp('{{ i.timestamp }}').getTime(),
	    {{ j.score }}
	  ]);
	{% endfor %}
      {% endif %}
    {% endfor %}

    var timelineData = [];
    for (i = 0; i < seriesData.length; ++i) {
	timelineData.push({
	    data: seriesData[i],
	    label: seriesLabels[i]
	});
    }

    var timeline = $.plot($("#timeline"), timelineData, options.timeline);
    console.log(timeline);
    plots["timeline"] = timeline;
  </script>
{% endmacro %}

{% macro render_grade_distribution_curve(submissions) %}
  <!-- The chart holder -->
  <div id="distributionChart" class="stats chartContainer">
    <h2>Recent submission distribution</h2>
    <div id="distribution" class="chart"></div>
  </div>
  <script type="text/javascript" src="/static/flot_helpers.js"></script>
  <script type="text/javascript">
    // Create Distribution curve.
    var distributionData = [ [] ];
    var distributionLabels = ["Total Score"];
    var distribution = [];
    var rangeCount = [ [] ];

    // Compute running mean and variance for normal distribution.
    var n = [0];
    var mean = [0.0];
    var variance = [0.0];
    var prev_mean = [0.0];
    {% for i in submissions %}
      {% if i.test_results and i.test_results_obj and
	i.test_results_obj.score is not none %}
	// Push on arrays for subtests if they exist
	if (distributionData.length === 1) {
	  {% for j in i.test_results_obj.tests %}
	    distributionData.push([]);
	    n.push(0);
	    mean.push(0.0);
	    variance.push(0.0);
	    prev_mean.push(0.0);
	    distributionLabels.push("{{ j.name }}");
	    users.push({});
	    rangeCount.push([]);
	  {% endfor %}
	}
    	var score = {{ i.test_results_obj.score }};
        rangeCount[0].push(score);

        // Allow multiple users to share same score.
        if (score in users[0]) {
            users[0][score] += ", {{ i.user }}";
	} else {
	    users[0][score] = "{{ i.user }}";
	}
        ++n[0];
        prev_mean[0] = mean[0];
        mean[0] = mean[0] + (score - mean[0]) / n[0];
        variance[0] = variance[0] + (score - mean[0]) * (score - prev_mean[0]);

	// Add subtest scores.
	{% for j in i.test_results_obj.tests %}
          score = {{ j.score }};
          index = {{ loop.index }};
          rangeCount[index].push(score);
          if (score in users[index]) {
              users[index][score] += ", {{ i.user }}";
	  } else {
	      users[index][score] = "{{ i.user }}";
	  }
          ++n[index];
          prev_mean[index] = mean[index];
          mean[index] = mean[index] + (score - mean[index]) / n[index];
          variance[index] = variance[index] + (score - mean[index]) *
                        (score - prev_mean[index]);
	{% endfor %}
      {% endif %}
    {% endfor %}

    stdDev = new Array(variance.length);
    for (var i = 0; i < variance.length; ++i) {
	variance[i] = variance[i] / n[i];
	stdDev[i] = Math.sqrt(variance[i]);
    }

    // Explicitly sort a and b as floats or lines will draw improperly.
    for (var i = 0; i < rangeCount.length; ++i) {
	rangeCount[i].sort(function(a, b) {
	    return parseFloat(a) - parseFloat(b);
	});
    }

    for (var i = 0; i < rangeCount.length; ++i) {
	for (var j = 0; j < rangeCount[i].length; ++j) {
	    distributionData[i].push([
		rangeCount[i][j],
		NormalDensityZx(rangeCount[i][j], mean[i], stdDev[i])
	    ]);
	}
    }

    for (var i = 0; i < rangeCount.length; ++i) {
	distribution.push({
	    data: distributionData[i],
	    label: distributionLabels[i]
	});
    }

    var distributionPlot = $.plot($("#distribution"), distribution,
				  options.distribution);

    plots["distribution"] = distributionPlot;
  </script>
{% endmacro %}

{% macro status_class(status) %}
  {% if "Failed" in status %}
    failed
  {% elif "Completed" in status %}
    success
  {% elif "timed out" in status %}
    timed_out
  {% elif "Waiting" in status %}
    waiting
  {% else %}
    submitted
  {% endif %}
{% endmacro %}
