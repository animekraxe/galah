#!/usr/bin/python

import random, string, json, sys, subprocess, os

def main():
    spec = json.load(sys.stdin)
    
    driver = MadLibDriver(
        "../testables", 
        spec.get("actions", []), 
        spec.get("config", {})
    )
        
    print json.dumps(driver.run())

class MadLibDriver:
    null_file = open("/dev/null", "w")
    
    def __init__(self, testables_directory, actions, config):
        self.testables_directory = testables_directory
        self.actions = actions
        self.config = config
        
        # The test_result we will be building
        self.test_result = {
            "subTests": [],
            "score": 0,
            "maxScore": 0
        }
        
        # Holds the subprocess object representing the student's binary
        self.student_bin = None
        
        # Holds the output of the studen'ts program
        self.program_output = None
        
        # Seed the random number generator from the configuration if specified
        # so all the students get the same test
        if "rand_seed" in self.config:
            random.seed(self.config["rand_seed"])
    
    @staticmethod
    def _include_sub_test(test_result, sub_test):
        "Adds the given sub test to the given test result."
        
        test_result["subTests"].append(sub_test)
        
        test_result["score"] += sub_test["score"]
        test_result["maxScore"] += sub_test["maxScore"]
        
    def run(self):
        if "compile" in self.actions:
            # Compile the students code    
            MadLibDriver._include_sub_test(self.test_result, self.compile_code())
        else:
            # Everything below this assumes that the code has been compiled. We
            # can't do anything more if we didn't compile it
            return self.test_result
        
        
        # Execute the student's compiled binary
        self.student_bin = subprocess.Popen(
            os.path.join(self.testables_directory, "main"),
            stdin = subprocess.PIPE,
            stdout = subprocess.PIPE,
            stderr = MadLibDriver.null_file
        )
        
        # Genereate a random set of 100 words to test. Only 10 will be used
        # but if the student's program takes in other input as well this way it
        # won't hang.
        def generate_word(length):
            return "".join(random.choice(string.letters) for i in xrange(3))
            
        self.words = [generate_word(random.randint(1, 10)) for i in xrange(100)]
        
        # Send the words to the student's program and record the output
        self.program_output = \
            self.student_bin.communicate("\n".join(self.words))[0]
            
        if "words_exist" in self.actions:
            MadLibDriver._include_sub_test(self.test_result, self.words_exist())

        return self.test_result
        
    def compile_code(self):
        # Compile the student's submission
        sub_test = {
            "name": "Compiles",
            "score": 0,
            "maxScore": 10
        }
        
        try:
            subprocess.check_call([
                "g++",
                "-o",
                os.path.join(self.testables_directory, "main"),
                os.path.join(self.testables_directory, "main.cpp")
            ])
            
            sub_test["score"] = 10
        except subprocess.CalledProcessError:
            sub_test["score"] = 0
        
        return sub_test    
    
    def words_exist(self):
        """
        Tests whether or not the words made it into the output. Only
        tests up to 10 words. A point is marked off for every
        missing word. Max points is 10.
        
        """ 
        
        test_result = {
            "name": "Words Exist",
            "score": 10,
            "maxScore": 10
        }
        
        # Subtract a point for every missing word. Note only 10 words are
        # tested
        missed_words = []
        for i in xrange(10):
            if self.words[i] not in self.program_output:
                test_result["score"] -= 1
                
                missed_words.append(str(i))
        
        if missed_words:
            test_result["message"] = "Words %s did not appear in the output." \
                                         % ", ".join(missed_words)
        
        # Return the score, the max score, and the message in a tuple
        return test_result

if __name__ == "__main__":
    main()

## Just another simple testing class
#class LineLengths:
    #"""
    #Tests whether every line of the output is between 60 and 80 characters
    #long. A point is taken off for every erroneous line. The total amount of
    #points possible is equal to the number of lines of output.
    #"""
    
    #def preparer(self):
        #return DefaultPreparer
        
    #def run(self, zpreparer):
        ## Split the output into lines
        #lines = zpreparer.programOutput.splitlines()
        
        ## Start with full points
        #score = len(lines)
        
        #for i in zpreparer.programOutput.splitlines():
            #if len(i) in range(60, 81):
                #score -= 1
                
        #return (score, len(lines))
